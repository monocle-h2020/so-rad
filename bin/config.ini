[DEFAULT]
# Timezone
# FIXME: shouldn't everything be in UTC? Check/Discuss where time zone is used/needed
time_zone_offset = 0
use_gpio_control = True
# if the platform has a fixed bearing enable / enter it here
use_fixed_bearing = False
fixed_bearing_deg = 148
# how often to check system readiness (and adjust viewing angles) for a measurement (lower this to ready system for measurement faster, but at higher power consumption)
# this is not the sampling interval, which is set in the RADIOMETERS section 
main_check_cycle_sec = 5

[SAMPLING]
# minimum speed in knots to allow sampling (on static platforms set to 0.0)
sampling_speed_limit = 0.0
# minimum solar elevation in degrees to allow sampling
solar_elevation_limit = 30.0

[DATABASE]
# note that you can rename an existing database file and/or move it away at any time to generate a new database. May require a restart of the So-rad software. 
use_database = True
database_type = sqlite3
database_path = /home/pi/sorad-data/sorad_database.db

[GPS]
# protocol will determine which GPS you will be using. Currently 'rtk' is supported, which is for the UBLOX FP9 chipset and highly recommended for moving installation. This will default to NMEA0183 protocol for any other value entered here. 
protocol = RTK
# number of gps units connected. Support for dual NMEA GPS will be deprecated soon. Recommend not to change this value. 
n_gps = 1
# baud rates
baud1 = 9600
baud2 = 9600
# polling rate in Hz (this is only used with one brand of GPS and will be deprecated)
set_polling_rate = False
polling_rate1 = 10
polling_rate2 = 10
# position of receivers on ship, needed to establish whether ship is moving forward or backward! It is assumed that the antennae align in parallel with the bow-stern axis of the ship. 
# if you find the heading is 180deg reversed, flip these around (there is no need to move the antennae around)
location1 = front
location2 = rear
# usb hub identifier defaults
id1 = id1
id2 = id2
# Lower_Limit of speed in knots to allow gps heading from single gps. THIS IS NOT USED - implement for single GPS only, where heading is not fixed (but then a dual antenna system is recommended).  
gps_heading_speed_limit = 1.0
# Upper limit of heading accuracy derived from RTK gps to allow heading to be used
gps_heading_accuracy_limit = 5.0
port_autodetect = True
#port_autodetect_string = CP2102 USB to UART Bridge Controller
port_autodetect_string = u-blox GNSS receiver
port1_default = /dev/ttyUSB1
port2_default = /dev/ttyUSB2
# GPIO control settings
use_gpio_control = False
gpio2 = 12

[MOTOR]
use_motor = true
#steps in one full rotation. Only configure this when programming the stepper motor. 
step_limit = 36000
steps_per_degree = 100
# clockwise and counter-clockwise limits of rotation in degrees. Configure this for each deployment platform. 
cw_limit_deg = 150
ccw_limit_deg = -160
# Minimum adjustment step interval (e.g. to save power). Note this is in steps not degrees (see steps_per_degree to convert). For example with threshold = 500 and steps_per_degree=100, no rotation of the motor < 5 degrees will be executed. 
step_thresh_angle = 500
# FIXME: is the following used? in seconds?
step_thresh_time = 10
# home_position of motor compared to ship bow-stern axis, in degrees (motor housing can also be turned on installation to keep this zero). It is advisable to align the home position of the motor with the bow-stern axis to keep things simple. 
home_pos = 10
port_autodetect = True
port_autodetect_string = USB-RS485 Cable
port_default = /dev/ttyUSB3
baud = 115200

[BATTERY]
use_battery = true
# battery_protocol: support for victron MPPT controllers is implemented
# for other protocols you should extend battery_manager.py, or set use_battery to false
battery_protocol = victron
port_autodetect = true
port_autodetect_string = TTL232R
port_default = /dev/ttyUSB4
baud = 19200
# low / critical battery voltage below which motor and sensors are stopped (GPIO control if available), respectively.
# these settings will be battery specific and should be above the voltage at which the solar charge controller will disconnect load
battery_low_th_V = 12.1
battery_crit_th_V = 11.6

[TPR]
use_tpr = true
# tilt/pitch/roll protocol: support for Adafruit board for ADXL345 is implemented as 'ada+adxl345'
# for other protocols you should extend tpr_manager.py
protocol = ada_adxl345
# indicate in which order the x,y,z accelerometer axes are reported (because the sensor may be mounted in arbitrary orientation). Default is y=2,z=0,x=1
yindex = 2
zindex = 0
xindex = 1
# In addition to live accelerometer readings you can take the average and stdev over the following interval in seconds to give an indication of wave action
# On small vessels set this close to the measurement integration time (in the order of 1 s max) so it will represent the variability during each Rrs measurement
# On larger vessels the relation between indidual waves and the optical geometry is lost, so use a longer interval to estimate the extent of heaving during a whole measurement repeat cycle (10-15s):
sampling_time = 5

[RADIOMETERS]
# curently only 'pytrios' is supported as rad_interface
rad_interface = pytrios
# No longer used: pytrios_path = /home/pi/Desktop/PyTrios
# up to three sensors supported, set to 0 to ignore radiometers completely
n_sensors = 3
# sampling interval in seconds
sampling_interval = 30
# set optional day/night independent sampling interval (sec) for Ed sensor
ed_sampling = True
ed_sampling_interval = 300
ed_sensor_id = 85EF
# PYTRIOS specific settings: how much logging output per sensor channel and com port
verbosity_chn = 3
verbosity_com = 3
# 0 = auto integration time
integration_time = 0

# GPIO control settings
use_gpio_control = True
gpio1 = 11
gpio2 = 13
gpio3 = 15

# allow reboot of radiometers (TriOS sensors have a tendency to get stuck on occasion)
allow_consecutive_timeouts = 2
minimum_reboot_interval_sec = 300

# PORT settings
port_autodetect = True
port_autodetect_string = USB-RS232 Cable
# defaults in case autodetect is not used or unsuccessful
port1 = USB3
port2 = USB4
port3 = USB5

[LOGGING]
# Log level for when you are logging stuffs
# Console log level controls what messages are outputted to the terminal.
# The other logging levels are what messages are outputted to the log files if set.
# The levels can be the following one of the following: CRITICAL CRIT ERROR WARNING WARN INFO DEBUG
# If not the default level is INFO
log_file_location = /home/pi/sorad-logs/log.txt
console_log_level = INFO
# TODO: only using root logger at the moment
gps_log_level = INFO
rad_log_level = INFO
bat_log_level = INFO

[SOS]
# Authentication key to communicate with SOS server
Auth = d1efd2791d1cf3bce41dea9480436524
UniqueID = soradTestSensor
